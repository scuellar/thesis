\section{Main theorem}
\label{sec:topbottom:theorem}

%We will start with an informal overview of the main theorem, followed by a the formal definitions and then a presentation of the Coq implementation and technical details.

In this subsection we will describe the main theorem of the top-to-bottom work. In the first part we introduce the formal definitions and state the theorem; in the second part, we describe the Coq implementations of the theorem and the technical details of the definitions. 

\subsection{Formal definitions}\label{sec:topbottomdefs}

\emph{Safety} includes: no execution of undefined instructions or loading from inaccessible memory; no violations of the spinlock well-synchronized property. Safety also includes partial correctness properties, such as, any finite prefix of the trace of input-output communications satisfies a specification.

\begin{reptheorem}{mainthm}[Main Theorem]\hypertarget{mainthm-formal}{
Given a source program $P$ satisfying a CSL specification $S$, and an
x86 assembly language program $Q$ obtained by CompCert compilation of
$P$: Any execution of $Q$ is safe (no undefined behavior), well
synchronized, and \emph{correct}---the data transmitted through lock
acquire/release events conforms to the resource invariants of $S$.}
\end{reptheorem}


\subsubsection{Correctness}

Threads communicate
by releasing and acquiring locks that control access to
data regions.  In terms of Concurrent Separation Logic, we say
a program is \emph{correct} if
the data in such regions always
satisfies an appropriate predicate---the \emph{resource invariant}---when
the corresponding
locks are released.
Therefore, any \emph{observer} of the program---a thread who communicates with
it by acquiring and releasing locks---will see only output
that satisfies this correctness specification.
Because our CSL has the appropriate partial-commutative-monoid ghost variables
\cite{jung2015iris}, resource invariants
can specify general protocol-correctness properties
and not just safety.

We summarize a thread's output
by monitoring the data controlled by locks as they are released,
and a thread's input via data controlled by locks acquired.
The event trace of locks acquired/released, and the contents of memory 
transferred by those locks, we preserve all the way from the
top level (CSL) to the bottom level (assembly) 
so that we can state correctness properties of
the assembly-language execution.

We have not yet formalized in Coq, this notion of preservation of specifications.


\subsection{Coq definitions}\label{sec:coqmainthm}


\todo{TODO: Will fill this in once CompCert\_new is merged into VST, and I can clean the main theorem.}
 

\autoref{coq:mainthm} shows the Coq statement of our main theorem 
\hyperlink{mainthm-formal}{\ref*{mainthm}}. We show how the code implements the theorem and explain the code below:



\begin{figure}
\begin{lstlisting}[numbers=left]
  Theorem top2bottom_correctness:
      (* C program is proven to be safe in CSL*)
      forall (main:AST.ident), CSL_correct C_program main  ->

      (* C program compiles to some assembly program*)
      CompCert_compiler C_program = Some Asm_program ->
        
      (* Statically checkable properties of ASM program *)
      forall (STATIC: static_validation Asm_program main),

      (* For all schedules, *)
      forall U : schedule,
        
      (*The asm program can be initialized with a memory and CPM state*)
      exists (m : mem) (cpm : CPM),
        initial_state Asm_program STATIC cpm m /\
        
        (* The assembly language program 
         is correct  and well-synchronized  *)
        spinlock_safe U cpm m.
\end{lstlisting}
\caption{Coq definition of our main theorem}\label{coq:mainthm}
\end{figure}

In what follows we explain how the code in \autoref{coq:mainthm} implements \autoref{mainthm}.
\begin{itemize}
%%CLIGHT PROOF
\item ``Given a source program $P$ satisfying a CSL specification $S$ ..." (lines 2-3):

\lstinline{CSL_correct C_program}: States that the program has been proven correct in CSL for some specification written in concurrent separation logic (starting at some main function \lstinline{main}) 
as described in \autoref{sec:CSLsound}.

%ASM compiled
\item ``... and an x86 assembly language program $Q$ obtained by CompCert compilation of
$P$ ..." (lines 5-9)

\begin{itemize}

\item \lstinline{CompCert_compiler}: States that the CompCert compiler translates 
\lstinline{C_program} into the assembly program \lstinline{Asm_program}.  

\item \lstinline{static_validation}: We validate the translation by statically checking a couple properties of the translated program \lstinline{Asm_program}. 
All of them are known to be preserved by the compiler, but the fact that CompCert preserves them has not yet been proven in Coq. We leave removing these conditions as future work. These properties are:
\begin{itemize}
\item \lstinline{limited_builtins}: The program only uses the builtins we currently support: \lstinline{memcopy}, \lstinline{mem_alloc}, \lstinline{mem_free}. These are the only builtins that CompCert inserts during compilation.
\item \lstinline{valid_mem}: The initial memory has no dangling pointers.
\item \lstinline{ge_wd}: The global environment is allocated in the initial memory. 
\item \lstinline{main_ident_correct}: The assembly program has an entry function named \lstinline{main}.
  
\end{itemize}

\end{itemize}

%%Safety.
\item ``...Any execution of $Q$ is safe (no undefined behavior), well
synchronized and correct." (lines 11-20)

\begin{itemize}
\item \lstinline{initial_state}: The program can be initialized with the initial memory $m$ and the initial CPM \lstinline{cpm}.

\item \lstinline{spinlock_safe}: For all executions (and for all schedules, quantified in line 11), the initial state is safe and well synchronized, as defined in \autoref{sec:weak}.

\end{itemize}

\end{itemize}
%
%\begin{itemize}
%
%
%\item \lstinline{CSL_correct C_program}: States that the program has been proven correct in CSL, 
%as described in  [section CSL ref] %TODO reference
%
%\item \lstinline{CompCert_compiler}: States that the CompCert compiler translates 
%\lstinline{C_program} into the assembly program \lstinline{Asm_program}.  
%
%\item \lstinline{CSL_init_setup}:  States that \lstinline{src_m} and \lstinline{src_cpm} are the initial 
%memory and state as defined by the program \lstinline{C_program}... According to CSL
%
%\item \lstinline{Clight.entry_point }: Same as above... According to Clight. %TODO
%
%\item \lstinline{limited_builtins}: Statically checkable property stating that \lstinline{Asm_program} 
%doesn't have unsupported builtins.
%
%\item \lstinline{asm_prog_well_formed}: Another statically checkable property stating that the initial 
%memory and global environment created by \lstinline{Asm_program} are well formed.
%\end{itemize}

%Conclusions:
%
%\begin{itemize}
%\item \lstinline{permissionless_init_machine}: There exists initial memories and state for \lstinline{Asm_program}
%
%\item \lstinline{spinlock_safe}: The initial state is safe and "spinlock well synchronized"
%as defined in [reference to spinlock]% Check how this is defnied  
%
%\end{itemize}


